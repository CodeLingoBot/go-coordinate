package cborrpc

import "bytes"
import "testing"
import "github.com/ugorji/go/codec"

func TestRpcRequestToBytes(t *testing.T) {
	cbor := new(codec.CborHandle)
	SetExts(cbor)

	req := Request{
		Method: "test",
		ID:     1,
		Params: []interface{}{},
	}
	// Note that this response hard-codes a parameter order in the
	// map, but this is not guaranteed.  This specific ordering
	// often passes.
	//
	// Also note that the string/bytes types match what are
	// generated by the encoder, but are a little goofy.  Since
	// the Python 2 receiver for the most part doesn't care what
	// goes back, this doesn't matter, much, which suggests we
	// should make it consistent.
	expected := []byte{
		// tag 24
		0xD8, 0x18,
		// byte string of length 25
		0x58, 0x19,
		// map of 3 pairs
		0xA3,
		// string "method"
		0x66, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64,
		// bytes "test"
		0x44, 0x74, 0x65, 0x73, 0x74,
		// string "id"
		0x62, 0x69, 0x64,
		// positive integer 1
		0x01,
		// string "params"
		0x66, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x73,
		// array of length 0
		0x80,
	}
	var actual []byte
	encoder := codec.NewEncoderBytes(&actual, cbor)
	err := encoder.Encode(req)
	if err != nil {
		t.Fatalf("Error encoding request: ", err)
	}
	if bytes.Compare(expected, actual) != 0 {
		t.Log("Encoding test failed")
		t.Log("Expected: ", expected)
		t.Log("Actual:   ", actual)
		t.Error()
	}
}

func TestEmptyTupleToBytes(t *testing.T) {
	cbor := new(codec.CborHandle)
	SetExts(cbor)

	tuple := PythonTuple{[]interface{}{}}
	expected := []byte{
		// tag 128
		0xD8, 0x80,
		// array of length 0
		0x80,
	}
	var actual []byte
	encoder := codec.NewEncoderBytes(&actual, cbor)
	err := encoder.Encode(tuple)
	if err != nil {
		t.Fatalf("Error encoding request: ", err)
	}
	if bytes.Compare(expected, actual) != 0 {
		t.Log("Encoding test failed")
		t.Log("Expected: ", expected)
		t.Log("Actual:   ", actual)
		t.Error()
	}
}

func TestBytesToEmptyTuple(t *testing.T) {
	cbor := new(codec.CborHandle)
	SetExts(cbor)

	bytes := []byte{
		// tag 128
		0xD8, 0x80,
		// array of length 0
		0x80,
	}
	expected := PythonTuple{[]interface{}{}}
	var actual PythonTuple
	encoder := codec.NewDecoderBytes(bytes, cbor)
	err := encoder.Decode(&actual)
	if err != nil {
		t.Fatalf("Error decoding request: ", err)
	}
	// this is hard to compare but we can cheat
	if len(actual.Items) > 0 {
		t.Log("Decoding test failed")
		t.Log("Expected: ", expected)
		t.Log("Actual:   ", actual)
		t.Error()
	}
}

func TestDecodeTupleReq(t *testing.T) {
	cbor := new(codec.CborHandle)
	SetExts(cbor)
	bytes := []byte{
		// tag 24
		0xD8, 0x18,
		// byte string of length 31
		0x58, 0x1F,
		// map of 3 pairs
		0xA3,
		// string "method"
		0x66, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64,
		// bytes "test"
		0x44, 0x74, 0x65, 0x73, 0x74,
		// string "id"
		0x62, 0x69, 0x64,
		// positive integer 1
		0x01,
		// string "params"
		0x66, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x73,
		// array of length 1
		0x81,
		// tag 128
		0xD8, 0x80,
		// array of length 2
		0x82,
		// string "k"
		0x61, 0x6B,
		// map of 0 pairs
		0xA0,
	}
	encoder := codec.NewDecoderBytes(bytes, cbor)
	var req Request
	err := encoder.Decode(&req)
	if err != nil {
		t.Fatalf("Error decoding request: ", err)
	}
	if req.Method != "test" {
		t.Errorf("Incorrect method %v, expected test", req.Method)
	}
	if req.ID != 1 {
		t.Errorf("Incorrect ID %v, expected 1", req.ID)
	}
	if len(req.Params) != 1 {
		t.Errorf("Incorrect number of params %v, expected 1", len(req.Params))
	} else {
		tuple, ok := req.Params[0].(PythonTuple)
		if !ok {
			t.Errorf("Incorrect param 1 %v, not tuple", req.Params[0])
		} else {
			if len(tuple.Items) != 2 {
				t.Errorf("Incorrect tuple length %v, not 2", len(tuple.Items))
			} else {
				if tuple.Items[0] != "k" {
					t.Errorf("Incorrect tuple item 0 %v, not 'k'", tuple.Items[0])
				}
				// TODO: check tuple.Items[1]
			}
		}
	}
}
