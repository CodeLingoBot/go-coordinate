package cborrpc

import "testing"
import "github.com/ugorji/go/codec"
import "reflect"
import "github.com/satori/go.uuid"

func encoderTest(t *testing.T, name string, obj interface{}, expecteds ...[]byte) {
	cbor := new(codec.CborHandle)
	SetExts(cbor)
	var actual []byte
	encoder := codec.NewEncoderBytes(&actual, cbor)
	err := encoder.Encode(obj)
	if err != nil {
		t.Fatalf("%v: error encoding request: %v", name, err)
	}
	good := false
	for _, expected := range expecteds {
		if reflect.DeepEqual(expected, actual) {
			good = true
			break
		}
	}
	if !good {
		t.Logf("%v: encoding test failed", name)
		t.Logf("Expected: %v", expecteds[0])
		t.Logf("Actual:   %v", actual)
		t.Error("")
	}
}

func concat(slices ...[]byte) (result []byte) {
	for _, slice := range slices {
		result = append(result, slice...)
	}
	return
}

func TestRpcRequestToBytes(t *testing.T) {
	req := Request{
		Method: "test",
		ID:     1,
		Params: []interface{}{},
	}
	// Since this is a map with 3 elements, there are 6 possible
	// orderings of iterating through it.  The map element pairs are
	method := []byte{
		// string "method"
		0x66, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64,
		// bytes "test"
		0x44, 0x74, 0x65, 0x73, 0x74,
	}
	id := []byte{
		// string "id"
		0x62, 0x69, 0x64,
		// positive integer 1
		0x01,
	}
	params := []byte{
		// string "params"
		0x66, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x73,
		// array of length 0
		0x80,
	}
	// and the "header" is
	header := []byte{
		// tag 24
		0xD8, 0x18,
		// byte string of length 25
		0x58, 0x19,
		// map of 3 pairs
		0xA3,
	}
	// Also note that the string/bytes types above match what are
	// generated by the encoder, but are a little goofy.  Since
	// the Python 2 receiver for the most part doesn't care what
	// goes back, this doesn't matter, much, which suggests we
	// should make it consistent.
	expecteds := [][]byte{
		concat(header, method, id, params),
		concat(header, method, params, id),
		concat(header, id, method, params),
		concat(header, id, params, method),
		concat(header, params, method, id),
		concat(header, params, id, method),
	}
	encoderTest(t, "TestRpcRequestToBytes", req, expecteds...)
}

func TestEmptyTupleToBytes(t *testing.T) {
	tuple := PythonTuple{[]interface{}{}}
	expected := []byte{
		// tag 128
		0xD8, 0x80,
		// array of length 0
		0x80,
	}
	encoderTest(t, "TestEmptyTupleToBytes", tuple, expected)
}

func TestListOfTupleToBytes(t *testing.T) {
	tuple := PythonTuple{[]interface{}{}}
	list := []PythonTuple{tuple}
	expected := []byte{
		// array of length 1
		0x81,
		// tag 128
		0xD8, 0x80,
		// array of length 0
		0x80,
	}
	encoderTest(t, "TestListOfTupleToBytes", list, expected)
}

func TestBytesToEmptyTuple(t *testing.T) {
	cbor := new(codec.CborHandle)
	SetExts(cbor)

	bytes := []byte{
		// tag 128
		0xD8, 0x80,
		// array of length 0
		0x80,
	}
	expected := PythonTuple{[]interface{}{}}
	var actual PythonTuple
	encoder := codec.NewDecoderBytes(bytes, cbor)
	err := encoder.Decode(&actual)
	if err != nil {
		t.Fatalf("Error decoding request: %v", err)
	}
	if !reflect.DeepEqual(actual, expected) {
		t.Log("Decoding test failed")
		t.Log("Expected: ", expected)
		t.Log("Actual:   ", actual)
		t.Error("")
	}
}

func TestDecodeTupleReq(t *testing.T) {
	cbor := new(codec.CborHandle)
	SetExts(cbor)
	bytes := []byte{
		// tag 24
		0xD8, 0x18,
		// byte string of length 31
		0x58, 0x1F,
		// map of 3 pairs
		0xA3,
		// string "method"
		0x66, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64,
		// bytes "test"
		0x44, 0x74, 0x65, 0x73, 0x74,
		// string "id"
		0x62, 0x69, 0x64,
		// positive integer 1
		0x01,
		// string "params"
		0x66, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x73,
		// array of length 1
		0x81,
		// tag 128
		0xD8, 0x80,
		// array of length 2
		0x82,
		// string "k"
		0x61, 0x6B,
		// map of 0 pairs
		0xA0,
	}
	encoder := codec.NewDecoderBytes(bytes, cbor)
	var req Request
	err := encoder.Decode(&req)
	if err != nil {
		t.Fatalf("Error decoding request: %v", err)
	}
	if req.Method != "test" {
		t.Errorf("Incorrect method %v, expected test", req.Method)
	}
	if req.ID != 1 {
		t.Errorf("Incorrect ID %v, expected 1", req.ID)
	}
	if len(req.Params) != 1 {
		t.Errorf("Incorrect number of params %v, expected 1", len(req.Params))
	} else {
		tuple, ok := req.Params[0].(PythonTuple)
		if !ok {
			t.Errorf("Incorrect param 1 %v, not tuple", req.Params[0])
		} else {
			if len(tuple.Items) != 2 {
				t.Errorf("Incorrect tuple length %v, not 2", len(tuple.Items))
			} else {
				if tuple.Items[0] != "k" {
					t.Errorf("Incorrect tuple item 0 %v, not 'k'", tuple.Items[0])
				}
				// TODO: check tuple.Items[1]
			}
		}
	}
}

func TestEncodeUUID(t *testing.T) {
	aUUID := uuid.NewV4()
	expected := []byte{
		// tag 37
		0xD8, 0x25,
		// byte string of length 16
		0x50,
	}
	expected = append(expected, aUUID.Bytes()...)
	encoderTest(t, "TestEncodeUUID", aUUID, expected)
}

func TestDecodeUUID(t *testing.T) {
	cbor := new(codec.CborHandle)
	SetExts(cbor)
	bytes := []byte{
		// tag 37
		0xD8, 0x25,
		// byte string of length 16
		0x50,
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
		0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	}
	expected := uuid.UUID{0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
		0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
		0x0E, 0x0F}
	var actual uuid.UUID
	encoder := codec.NewDecoderBytes(bytes, cbor)
	err := encoder.Decode(&actual)
	if err != nil {
		t.Fatalf("Error decoding request: %v", err)
	}
	if !reflect.DeepEqual(actual, expected) {
		t.Log("Decoding test failed")
		t.Log("Expected: ", expected)
		t.Log("Actual:   ", actual)
		t.Error("")
	}
}
