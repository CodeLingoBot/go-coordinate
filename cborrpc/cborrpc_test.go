// Copyright 2015-2016 Diffeo, Inc.
// This software is released under an MIT/X11 open source license.

package cborrpc

import (
	"bytes"
	"github.com/satori/go.uuid"
	"github.com/stretchr/testify/assert"
	"github.com/ugorji/go/codec"
	"testing"
)

var cbor *codec.CborHandle

func init() {
	cbor = new(codec.CborHandle)
	err := SetExts(cbor)
	if err != nil {
		panic(err)
	}
}

func encoderTest(t *testing.T, obj interface{}, expecteds ...[]byte) {
	var actual []byte
	encoder := codec.NewEncoderBytes(&actual, cbor)
	err := encoder.Encode(obj)
	if assert.NoError(t, err) {
		assert.Contains(t, expecteds, actual)
	}
}

func concat(slices ...[]byte) (result []byte) {
	for _, slice := range slices {
		result = append(result, slice...)
	}
	return
}

func TestRpcRequestToBytes(t *testing.T) {
	req := Request{
		Method: "test",
		ID:     1,
		Params: []interface{}{},
	}
	// Since this is a map with 3 elements, there are 6 possible
	// orderings of iterating through it.  The map element pairs are
	method := []byte{
		// byte string "method"
		0x46, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64,
		// bytes "test"
		0x44, 0x74, 0x65, 0x73, 0x74,
	}
	id := []byte{
		// byte string "id"
		0x42, 0x69, 0x64,
		// positive integer 1
		0x01,
	}
	params := []byte{
		// byte string "params"
		0x46, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x73,
		// array of length 0
		0x80,
	}
	// and the "header" is
	header := []byte{
		// tag 24
		0xD8, 0x18,
		// byte string of length 25
		0x58, 0x19,
		// map of 3 pairs
		0xA3,
	}
	// Also note that the string/bytes types above match what are
	// generated by the encoder, but are a little goofy.  Since
	// the Python 2 receiver for the most part doesn't care what
	// goes back, this doesn't matter, much, which suggests we
	// should make it consistent.
	expecteds := [][]byte{
		concat(header, method, id, params),
		concat(header, method, params, id),
		concat(header, id, method, params),
		concat(header, id, params, method),
		concat(header, params, method, id),
		concat(header, params, id, method),
	}
	encoderTest(t, req, expecteds...)
}

func TestEmptyTupleToBytes(t *testing.T) {
	tuple := PythonTuple{[]interface{}{}}
	expected := []byte{
		// tag 128
		0xD8, 0x80,
		// array of length 0
		0x80,
	}
	encoderTest(t, tuple, expected)
}

func TestReallyEmptyTupleToBytes(t *testing.T) {
	tuple := PythonTuple{}
	expected := []byte{
		// tag 128
		0xD8, 0x80,
		// array of length 0
		0x80,
	}
	encoderTest(t, tuple, expected)
}

func TestListOfTupleToBytes(t *testing.T) {
	tuple := PythonTuple{[]interface{}{}}
	list := []PythonTuple{tuple}
	expected := []byte{
		// array of length 1
		0x81,
		// tag 128
		0xD8, 0x80,
		// array of length 0
		0x80,
	}
	encoderTest(t, list, expected)
}

func TestBytesToEmptyTuple(t *testing.T) {
	bytes := []byte{
		// tag 128
		0xD8, 0x80,
		// array of length 0
		0x80,
	}
	expected := PythonTuple{[]interface{}{}}
	var actual PythonTuple
	encoder := codec.NewDecoderBytes(bytes, cbor)
	err := encoder.Decode(&actual)
	if assert.NoError(t, err) {
		assert.Equal(t, expected, actual)
	}
}

func TestDecodeTupleReq(t *testing.T) {
	bytes := []byte{
		// tag 24
		0xD8, 0x18,
		// byte string of length 31
		0x58, 0x1F,
		// map of 3 pairs
		0xA3,
		// byte string "method"
		0x46, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64,
		// bytes "test"
		0x44, 0x74, 0x65, 0x73, 0x74,
		// byte string "id"
		0x42, 0x69, 0x64,
		// positive integer 1
		0x01,
		// byte string "params"
		0x46, 0x70, 0x61, 0x72, 0x61, 0x6D, 0x73,
		// array of length 1
		0x81,
		// tag 128
		0xD8, 0x80,
		// array of length 2
		0x82,
		// string "k"
		0x61, 0x6B,
		// map of 0 pairs
		0xA0,
	}
	encoder := codec.NewDecoderBytes(bytes, cbor)
	var req Request
	err := encoder.Decode(&req)
	if assert.NoError(t, err) {
		assert.Equal(t, "test", req.Method)
		assert.EqualValues(t, 1, req.ID)
		if assert.Len(t, req.Params, 1) {
			assert.Equal(t, PythonTuple{Items: []interface{}{
				"k",
				map[interface{}]interface{}{},
			}}, req.Params[0])
		}
	}
}

func TestEncodeUUID(t *testing.T) {
	aUUID := uuid.NewV4()
	expected := []byte{
		// tag 37
		0xD8, 0x25,
		// byte string of length 16
		0x50,
	}
	expected = append(expected, aUUID.Bytes()...)
	encoderTest(t, aUUID, expected)
}

func TestDecodeUUID(t *testing.T) {
	bytes := []byte{
		// tag 37
		0xD8, 0x25,
		// byte string of length 16
		0x50,
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
		0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
	}
	expected := uuid.UUID{0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
		0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,
		0x0E, 0x0F}
	var actual uuid.UUID
	encoder := codec.NewDecoderBytes(bytes, cbor)
	err := encoder.Decode(&actual)
	if assert.NoError(t, err) {
		assert.Equal(t, expected, actual)
	}
}

// DeTest holds data for a decoding test.
type DeTest struct {
	Data  []byte
	Value interface{}
}

func DeTestByteString(v string) DeTest {
	return DeTest{
		Data:  append([]byte{0x40 + byte(len(v))}, []byte(v)...),
		Value: []byte(v),
	}
}

// TestDecodeRegressions checks various bits of the codec library.
func TestDecodeRegressions(t *testing.T) {
	tests := make(map[string]DeTest)
	tests["kList"] = DeTestByteString("list")
	tests["vList"] = DeTest{
		Data:  []byte{0x83, 0x01, 0x02, 0x03},
		Value: []interface{}{uint64(1), uint64(2), uint64(3)},
	}
	tests["kTuple"] = DeTestByteString("tuple")
	tests["vTuple"] = DeTest{
		Data:  []byte{0xd8, 0x80, 0x83, 0x04, 0x05, 0x06},
		Value: PythonTuple{Items: []interface{}{uint64(4), uint64(5), uint64(6)}},
	}
	tests["kMixed"] = DeTestByteString("mixed")
	tests["vMixed"] = DeTest{
		Data: []byte{0x82, 0x01, 0xD8, 0x80, 0x82, 0x02, 0x82, 0x03, 0x04},
		Value: []interface{}{
			uint64(1),
			PythonTuple{Items: []interface{}{
				uint64(2),
				[]interface{}{uint64(3), uint64(4)},
			}},
		},
	}
	tests["kUUID"] = DeTestByteString("uuid")
	tests["vUUID"] = DeTest{
		Data:  []byte{0xd8, 0x25, 0x50, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10},
		Value: uuid.FromStringOrNil("01020304-0506-0708-090a-0b0c0d0e0f10"),
	}
	tests["kStr"] = DeTestByteString("str")
	tests["vStr"] = DeTest{
		Data:  []byte{0x43, 0x66, 0x6f, 0x6f},
		Value: []byte{0x66, 0x6f, 0x6f},
	}
	tests["kUnicode"] = DeTestByteString("unicode")
	tests["vUnicode"] = DeTest{
		Data:  []byte{0x63, 0x66, 0x6f, 0x6f},
		Value: "foo",
	}
	tests["smallMap"] = DeTest{
		Data: bytes.Join([][]byte{
			[]byte{0xA6},
			tests["kList"].Data,
			tests["vList"].Data,
			tests["kTuple"].Data,
			tests["vTuple"].Data,
			tests["kMixed"].Data,
			tests["vMixed"].Data,
			tests["kUUID"].Data,
			tests["vUUID"].Data,
			tests["kStr"].Data,
			tests["vStr"].Data,
			tests["kUnicode"].Data,
			tests["vUnicode"].Data,
		}, []byte{}),
		Value: map[interface{}]interface{}{
			"list":    tests["vList"].Value,
			"tuple":   tests["vTuple"].Value,
			"mixed":   tests["vMixed"].Value,
			"uuid":    tests["vUUID"].Value,
			"str":     tests["vStr"].Value,
			"unicode": tests["vUnicode"].Value,
		},
	}
	tests["mapOfMap"] = DeTest{
		Data: bytes.Join([][]byte{
			[]byte{0xA1, 0x41, 0x61},
			tests["smallMap"].Data,
		}, []byte{}),
		Value: map[interface{}]interface{}{
			"a": tests["smallMap"].Value,
		},
	}
	tests["tupleOfNested"] = DeTest{
		Data: bytes.Join([][]byte{
			[]byte{0xD8, 0x80, 0x81},
			tests["mapOfMap"].Data,
		}, []byte{}),
		Value: PythonTuple{Items: []interface{}{tests["mapOfMap"].Value}},
	}
	tests["kvps"] = DeTest{
		Data: bytes.Join([][]byte{
			[]byte{0x81, 0xD8, 0x80, 0x81 /* 0x82, 0x41, 0x61 */},
			tests["smallMap"].Data,
		}, []byte{}),
		Value: []interface{}{
			PythonTuple{Items: []interface{}{
				// []byte{0x61},
				tests["smallMap"].Value,
			}},
		},
	}
	tests["miniKvp"] = DeTest{
		Data: []byte{0x81, 0xd8, 0x80, 0x82, 0x41, 0x61, 0x41, 0x62},
		Value: []interface{}{
			PythonTuple{Items: []interface{}{
				[]byte{0x61},
				[]byte{0x62},
			}},
		},
	}
	tests["miniKvp2"] = DeTest{
		Data: []byte{0x81, 0xd8, 0x80, 0x82, 0x41, 0x61, 0xA0},
		Value: []interface{}{
			PythonTuple{Items: []interface{}{
				[]byte{0x61},
				map[interface{}]interface{}{},
			}},
		},
	}
	tests["params"] = DeTest{
		Data: bytes.Join([][]byte{
			[]byte{0x82},
			DeTestByteString("spec").Data,
			tests["kvps"].Data,
		}, []byte{}),
		Value: []interface{}{
			DeTestByteString("spec").Value,
			tests["kvps"].Value,
		},
	}
	tests["topLevelMap"] = DeTest{
		Data: bytes.Join([][]byte{
			[]byte{0xA3},
			DeTestByteString("params").Data,
			tests["params"].Data,
			DeTestByteString("id").Data,
			[]byte{0x02},
			DeTestByteString("method").Data,
			DeTestByteString("add_work_units").Data,
		}, []byte{}),
		Value: map[interface{}]interface{}{
			"params": tests["params"].Value,
			"id":     uint64(2),
			"method": []byte("add_work_units"),
		},
	}
	tests["request"] = DeTest{
		Data: bytes.Join([][]byte{
			[]byte{0xD8, 0x18, 0x58, byte(len(tests["topLevelMap"].Data))},
			tests["topLevelMap"].Data,
		}, []byte{}),
		Value: Request{
			Method: "add_work_units",
			ID:     2,
			Params: tests["params"].Value.([]interface{}),
		},
	}

	for name, test := range tests {
		decoder := codec.NewDecoderBytes(test.Data, cbor)
		var actual interface{}
		err := decoder.Decode(&actual)
		if assert.NoError(t, err, "%v", name) {
			assert.Equal(t, test.Value, actual, "%v", name)
		}
	}
}
